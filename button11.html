<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>복백과사전</title>
  <style>
    * { box-sizing: border-box; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    body { margin: 0; padding: 12px; background: #f5f5f5; }
    button { cursor: pointer; border-radius: 10px; border: 1px solid #ddd; background: #fff; padding: 8px 10px; font-size: 13px; text-align:center; }
    button:active { transform: scale(0.98); }
    button:disabled { opacity: .45; cursor: not-allowed; }
    input, select, textarea { font: inherit; }

    .app {
      max-width: 1200px; margin: 0 auto; background: #fff;
      border-radius: 14px; padding: 12px; box-shadow: 0 2px 10px rgba(0,0,0,0.08);
      min-height: calc(100vh - 24px);
      display:flex; flex-direction:column; gap:10px;
      position: relative;
    }

    .header { display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap; }
    .title { margin:0; font-size:18px; display:flex; align-items:center; gap:10px; }

    .header-right { display:flex; align-items:center; gap:8px; flex-wrap:wrap; justify-content:flex-end; }
    .pill {
      font-size:12px; padding:4px 10px; border-radius:999px;
      border:1px solid #ddd; background:#fafafa; font-weight:800;
      max-width: 320px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
      text-align:center;
    }

    .movebox,.searchbox{
      display:none; align-items:center; gap:6px; flex-wrap:wrap;
      padding:6px; border:1px solid #eee; border-radius:12px; background:#fafafa;
      position: relative;
    }
    .movebox.show,.searchbox.show{ display:flex; }
    .move-search,.search-input{
      border:1px solid #ddd; border-radius:12px; padding:8px 10px; font-size:13px;
      min-width: 260px; outline:none; background:#fff;
    }
    .search-input{ min-width: 320px; }
    .smallpill{
      font-size:12px; padding:4px 10px; border-radius:999px;
      border:1px solid #ddd; background:#fff; font-weight:800;
      text-align:center;
    }

    .dropdown{
      position:absolute; top: calc(100% + 6px); right: 0;
      width: min(760px, 92vw);
      max-height: 340px;
      overflow:auto;
      background:#fff;
      border:1px solid #ddd;
      border-radius:12px;
      box-shadow:0 8px 24px rgba(0,0,0,0.12);
      padding:8px;
      display:none;
      z-index: 99;
    }
    .dropdown.show{ display:block; }
    .res-item{
      display:flex; gap:8px; align-items:center;
      background:#fff; border:1px solid transparent;
      border-radius:10px; padding:8px; margin-bottom:6px;
      cursor:pointer;
    }
    .res-item:last-child{ margin-bottom:0; }
    .res-item:hover{ border-color:#ddd; }
    .res-title{ font-size:13px; font-weight:800; }
    .res-path{ font-size:11px; opacity:.65; margin-left:auto; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width: 360px; }
    .res-tag{
      font-size:11px; padding:2px 8px; border-radius:999px;
      border:1px solid #e6e6e6; background:#fafafa; font-weight:900; opacity:.9;
      white-space:nowrap;
    }

    .nav-mini{ display:flex; align-items:center; gap:8px; flex-wrap:wrap; }
    .nav-left{ display:flex; gap:6px; flex-wrap:wrap; align-items:center; }
    .nav-right{ margin-left:auto; display:flex; gap:6px; flex-wrap:wrap; align-items:center; }
    .mode-btn{ font-weight:800; background:#fafafa; border-color:#ddd; }
    .mode-btn.active{ background:#eef7ff; border-color:#b3d4ff; }
    .mode-btn.memo{ font-weight:950; }

    .editpanel{
      display:none;
      border:1px solid #eee;
      border-radius:12px;
      background:#fafafa;
      padding:10px;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .editpanel.show{ display:flex; }

    .backuppanel{
      display:none;
      border:1px solid #eee;
      border-radius:12px;
      background:#fafafa;
      padding:10px;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .backuppanel.show{ display:flex; }
    .backuppanel .hintline{ font-size:12px; opacity:.65; }
    .backuppanel button{ font-weight:900; background:#fff; }

    .editpanel label{
      display:flex; align-items:center; gap:8px;
      font-size:12px;
      padding:6px 10px;
      border:1px solid #e6e6e6;
      border-radius:999px;
      background:#fff;
    }
    .range{ width: 240px; }
    .kv{ font-weight:900; min-width: 50px; text-align:right; }

    .crumbbar{
      display:flex; flex-wrap:wrap; gap:6px; align-items:center;
      padding:10px; border:1px solid #eee; border-radius:12px; background:#fafafa;
    }
    .crumb-chip{
      display:inline-flex; align-items:center; justify-content:center;
      border:1px solid #ddd; background:#fff;
      padding:7px 10px; border-radius:999px; font-size:12px;
      text-align:center;
      white-space:nowrap;
    }
    .crumb-chip.active{ background:#eef7ff; border-color:#b3d4ff; font-weight:900; }
    .crumb-sep{ opacity:.45; user-select:none; }

    .split{
      --panePad: 12px;
      --hCtrlMin: 44px;
      flex: 1; display:flex; min-height: 0;
      border:1px solid #eee; border-radius:14px; overflow:hidden; background:#fff;
      min-width:0;
      position: relative;
    }
    .pane{
      min-height: 0;
      min-width: 0;
      overflow: hidden;
      padding: 0;
      background:#fff;
      display:flex;
      flex-direction:column;
    }
    .divider{
      width: 8px; background: #f2f2f2;
      border-left: 1px solid #e6e6e6; border-right: 1px solid #e6e6e6;
      cursor: col-resize; position: relative;
      flex: 0 0 auto;
      user-select:none;
      touch-action:none;
    }
    .divider::after{
      content:""; position:absolute; top: 50%; left: 50%;
      width: 3px; height: 44px; transform: translate(-50%,-50%);
      border-radius: 999px; background: #d7d7d7;
      box-shadow: -6px 0 0 #d7d7d7, 6px 0 0 #d7d7d7;
      opacity: .9;
    }

    #leftPane { width:50%; min-width:0; flex: 0 0 auto; }
    #rightPane{ width:auto; min-width:0; background:#fff; flex: 1 1 auto; }

    .scrollWrap{
      flex: 1;
      min-height: 0;
      min-width: 0;
      overflow: auto;
      padding: var(--panePad);
      transition: padding 160ms ease;
      overscroll-behavior: contain;
    }

    #leftScrollWrap, #rightScrollWrap{
      overflow-x: auto;
      overflow-y: auto;
      scrollbar-width: none;
    }
    #leftScrollWrap::-webkit-scrollbar,
    #rightScrollWrap::-webkit-scrollbar{ height: 0; width: 0; }

    .hctrl{
      display:flex;
      align-items:center;
      gap:6px;
      height: 18px;
      margin: 8px var(--panePad) 12px;
      user-select:none;
      flex:0 0 auto;
      min-width: var(--hCtrlMin);
    }
    .hbtn{
      width: 22px;
      height: 18px;
      padding: 0;
      border-radius: 6px;
      font-size: 12px;
      line-height: 16px;
      display:flex;
      align-items:center;
      justify-content:center;
      background:#fff;
    }
    .hbtn:disabled{ opacity:.35; }

    .htrack{
      position: relative;
      height: 10px;
      flex: 1;
      border: 1px solid #e6e6e6;
      border-radius: 999px;
      background: #f3f3f3;
      min-width: 8px;
      overflow:hidden;
    }
    .hthumb{
      position:absolute;
      top:-1px;
      bottom:-1px;
      left:0;
      width: 44px;
      border-radius: 999px;
      border: 1px solid #d8d8d8;
      background: #fff;
      cursor: grab;
    }
    .hthumb:active{ cursor: grabbing; }

    .btn-row{
      display:flex;
      align-items:stretch;
      margin-bottom:6px;
      flex-wrap: nowrap;
      gap: 0;
      width: max-content;
      min-width: 100%;
    }
    .btn-main{
      flex: 0 0 auto;
      flex-shrink: 0;
      text-align:center;
      padding:10px;
      border-radius:12px;
      border:1px solid #ccc;
      background:#fafafa;
      font-size:14px;
      min-height:42px;
      white-space: pre-line;
      overflow: hidden;
      word-break: break-word;
      line-height: 1.25;
    }
    .btn-main.active{ background:#eef7ff; border-color:#b3d4ff; font-weight:900; }

    .btn-controls{
      flex: 0 0 auto;
      flex-shrink: 0;
      display:flex;
      gap:2px;
      flex-wrap:nowrap;
      justify-content:flex-start;
      align-items:stretch;
      margin-left: 0;
      min-width: 0;
    }
    .btn-controls button{
      font-size:11px;
      padding:6px 8px;
      border-radius:10px;
      text-align:center;
      white-space:nowrap;
      flex: 0 0 auto;
      flex-shrink: 0;
      min-width: 38px;
    }

    .addbar{
      flex: 0 0 auto;
      padding: 10px 12px 10px;
      border-top: 1px solid #eee;
      background: #fff;
      display:flex;
      justify-content:center;
      align-items:center;
      gap:8px;
    }
    .addbar button{
      font-weight: 900;
      padding: 10px 12px;
      border-radius: 12px;
      background:#fafafa;
      border-color: #ddd;
      flex: 1;
      max-width: 320px;
    }

    .empty-text{
      padding:10px; border:1px dashed #ddd; border-radius:12px;
      font-size:13px; opacity:.75; white-space:pre-wrap; background:#fbfbfb;
      text-align:center;
    }

    .note-head{
      display:flex; align-items:flex-start; justify-content:space-between; gap:10px; flex-wrap:wrap;
      margin-bottom: 10px;
    }
    .note-title{
      font-size:14px; font-weight:900;
      display:flex; gap:8px; align-items:center; flex-wrap:wrap;
    }
    .badge{
      font-size:11px; padding:3px 9px; border-radius:999px;
      border:1px solid #ddd; background:#fafafa; font-weight:900; opacity:.9;
      max-width: 420px; overflow:hidden; text-overflow:ellipsis; white-space:nowrap;
      text-align:center;
    }
    .note-actions{ display:flex; gap:6px; flex-wrap:wrap; }

    .note-view{
      border:1px solid #eee; background:#fafafa; border-radius:12px;
      padding:10px; min-height: 260px; white-space:normal; line-height:1.55;
      font-size:13px; overflow:auto;
    }
    .note-view .note-empty{ opacity:.65; font-style: italic; }

    .editor-toolbar{
      display:flex; flex-wrap:wrap; gap:6px; align-items:center;
      border:1px solid #ddd; border-radius:12px;
      padding:8px; background:#fafafa;
      margin-bottom:8px;
    }
    .toolbtn{ padding:6px 10px; border-radius:10px; font-size:12px; background:#fff; }
    .colorpick{
      width: 42px; height: 32px; padding: 0;
      border-radius: 10px; border: 1px solid #ddd;
      background:#fff; cursor:pointer;
    }
    .toolselect{
      height: 32px; border-radius:10px; border:1px solid #ddd;
      padding:0 10px; background:#fff; font-size:12px;
    }

    .note-editor{
      border:1px solid #ddd; border-radius:12px;
      padding:10px; min-height: 360px;
      background:#fff; outline:none; overflow:auto;
      line-height:1.55; font-size:13px; white-space: normal;
    }
    .note-editor table{
      border-collapse: collapse;
      table-layout: fixed;
      width: max-content;
      max-width: 100%;
      min-width: 240px;
      background:#fff;
    }
    .note-editor td, .note-editor th{
      border:1px solid #666;
      padding:6px;
      min-width:48px;
      vertical-align: top;
      position: relative;
      overflow: hidden;
      word-break: break-word;
    }
    .note-editor td:focus, .note-editor th:focus{ outline: 2px solid #b3d4ff; }
    .note-editor:empty::before{ content:"여기에 내용을 입력하세요..."; color:#999; }

    /* ✅ (추가) 오른쪽 내용 영역 내부: 위(속성/툴바) ↔ 아래(내용) 드래그 분할 */
    .inner-split{
      display:flex;
      flex-direction: column;
      min-width:0;
      border:1px solid #eee;
      border-radius:12px;
      overflow:hidden;
      background:#fff;
      height: calc(100% - 0px);
    }
    .inner-pane{
      min-width:0;
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }
    #propPane{
      flex: 0 0 auto;
      height: 220px; /* 기본 */
      width: 100%;
      background:#fff;
    }
    #contentPane{
      flex: 1 1 auto;
      width: 100%;
      background:#fff;
    }
    .inner-divider{
      height: 8px;
      width: 100%;
      background:#f2f2f2;
      border-top:1px solid #e6e6e6;
      border-bottom:1px solid #e6e6e6;
      cursor: row-resize;
      position:relative;
      flex: 0 0 auto;
      user-select:none;
      touch-action:none;
    }
    .inner-divider::after{
      content:"";
      position:absolute; top:50%; left:50%;
      width:44px; height:3px; transform:translate(-50%,-50%);
      border-radius:999px; background:#d7d7d7;
      box-shadow: 0 -6px 0 #d7d7d7, 0 6px 0 #d7d7d7;
      opacity:.9;
    }
    .prop-scroll{
      padding: 10px;
      overflow:auto;
      min-height: 100%;
    }
    .content-scroll{
      padding: 10px;
      overflow:auto;
      min-height: 100%;
    }

    /* ✅ (수정) 모달 z-index를 메모창보다 위로 올림 */
    .modal-backdrop{
      position: fixed; inset: 0;
      background: rgba(0,0,0,.35);
      display:none;
      align-items:center;
      justify-content:center;
      z-index: 100000; /* ← memo-window(99999)보다 크게 */
      padding: 12px;
    }
    .modal-backdrop.show{ display:flex; }
    .modal{
      width: min(520px, 95vw);
      background:#fff;
      border-radius:14px;
      border:1px solid #e6e6e6;
      box-shadow:0 12px 36px rgba(0,0,0,.18);
      padding: 12px;
    }
    .modal h3{ margin: 0 0 10px; font-size:14px; }
    .modal .row{
      display:flex; gap:8px; align-items:center; flex-wrap:wrap;
      margin-bottom:10px;
    }
    .modal label{
      font-size:12px; display:flex; gap:6px; align-items:flex-start;
      background:#fafafa; border:1px solid #eee; padding:8px 10px; border-radius:12px;
      flex:1; min-width: 160px;
      flex-direction: column;
    }
    .modal textarea{
      width: 100%;
      padding:8px 10px;
      border:1px solid #ddd;
      border-radius:10px;
      outline:none;
      background:#fff;
      font-size:13px;
      min-height: 110px;
      resize: vertical;
      white-space: pre-wrap;
      line-height: 1.3;
    }
    /* ✅ (추가) 백업 파일명 입력용 */
    .modal input[type="text"]{
      width: 100%;
      padding:8px 10px;
      border:1px solid #ddd;
      border-radius:10px;
      outline:none;
      background:#fff;
      font-size:13px;
      line-height: 1.3;
    }

    .modal .actions{
      display:flex; gap:8px; justify-content:flex-end; flex-wrap:wrap;
    }
    .hint{ font-size:12px; opacity:.65; margin-top: 6px; }

    .stat-grid{ display:grid; grid-template-columns: 1fr; gap:8px; margin-top:10px; }
    .stat-card{
      border:1px solid #eee; border-radius:12px; background:#fafafa;
      padding:10px; display:flex; justify-content:space-between; align-items:center; gap:10px;
    }
    .stat-k{ font-size:12px; opacity:.75; font-weight:800; }
    .stat-v{ font-size:16px; font-weight:950; }
    .mono{ font-variant-numeric: tabular-nums; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }

    /* =========================================================
       ✅ 메모모드: 떠있는 창 (드래그 이동 + resize)
       ========================================================= */
    .memo-window{
      position: fixed;
      top: 120px; left: 60px;
      width: 760px; height: 420px;
      max-width: calc(100vw - 24px);
      max-height: calc(100vh - 24px);
      background:#fff;
      border:1px solid #e6e6e6;
      border-radius:14px;
      box-shadow:0 12px 36px rgba(0,0,0,0.18);
      z-index: 99999;
      display:none;
      overflow:hidden;
      resize: both;
    }
    .memo-window.show{ display:block; }

    .memo-header{
      height: 42px;
      display:flex;
      align-items:center;
      gap:8px;
      padding: 8px 10px;
      background:#fafafa;
      border-bottom:1px solid #eee;
      cursor: grab;
      user-select:none;
      touch-action:none;
    }
    .memo-header:active{ cursor: grabbing; }
    .memo-title{
      font-weight:950;
      font-size:13px;
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
      min-width: 0;
    }
    .memo-badge{
      font-size:11px;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid #ddd;
      background:#fff;
      font-weight:950;
      white-space:nowrap;
    }
    .memo-loc{
      font-size:11px;
      opacity:.65;
      font-weight:900;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 360px;
    }
    .memo-spacer{ margin-left:auto; display:flex; gap:6px; align-items:center; }
    .memo-close{
      font-size:12px;
      padding:6px 10px;
      border-radius:12px;
      font-weight:950;
      background:#fff;
    }

    .memo-body{
      height: calc(100% - 42px);
      display:flex;
      gap:10px;
      padding:10px;
      overflow:hidden;
    }
    .memo-left{
      width: 360px;
      min-width: 260px;
      flex: 0 0 auto;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .memo-input{
      width:100%;
      border:1px solid #ddd;
      border-radius:12px;
      padding:10px;
      min-height: 86px;
      resize: none;
      font-size:13px;
      outline:none;
    }
    .memo-actions{
      display:flex;
      gap:6px;
      flex-wrap:wrap;
    }
    .memo-actions button{
      font-size:12px;
      font-weight:950;
      padding:7px 10px;
      border-radius:12px;
      background:#fafafa;
    }
    .memo-hint{
      font-size:12px;
      opacity:.65;
      line-height:1.25;
      border:1px solid #eee;
      background:#fafafa;
      border-radius:12px;
      padding:8px 10px;
      white-space:pre-wrap;
    }
    .memo-right{
      flex: 1 1 auto;
      min-width: 260px;
      border:1px solid #eee;
      border-radius:12px;
      background:#fafafa;
      overflow:auto;
      padding:8px;
    }

    .log-item{
      display:flex;
      gap:8px;
      align-items:flex-start;
      background:#fff;
      border:1px solid #eee;
      border-radius:12px;
      padding:8px;
      margin-bottom:8px;
    }
    .log-item:last-child{ margin-bottom:0; }
    .log-check{ margin-top: 4px; }
    .log-body{ flex:1; min-width:0; }
    .log-time{
      font-size:11px; opacity:.65; font-weight:900;
      margin-bottom:4px;
      white-space:nowrap;
    }
    .log-text{
      font-size:13px; line-height:1.35;
      white-space: pre-wrap;
      word-break: break-word;
    }
    .log-tag{
      font-size:11px;
      padding:2px 8px;
      border-radius:999px;
      border:1px solid #e6e6e6;
      background:#fafafa;
      font-weight:900;
      opacity:.9;
      white-space:nowrap;
      flex: 0 0 auto;
      margin-left:auto;
      max-width: 240px;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    /* ✅ (추가) 메모 수정 모달 드래그 핸들 */
    #memoEditModal .modal h3{
      cursor: grab;
      user-select:none;
      touch-action:none;
    }
    #memoEditModal .modal h3:active{ cursor: grabbing; }
  </style>
</head>

<body>
<div class="app">
  <div class="header">
    <h1 class="title">버튼 트리</h1>
    <div class="header-right">
      <div class="movebox" id="moveBox">
        <span class="pill" id="movePillSource">출발: -</span>
        <span class="pill" id="movePillTarget">대상: -</span>
        <input class="move-search" id="moveSearchInput" placeholder="대상 검색 후 선택" />
        <button id="btnMoveConfirm" type="button" disabled>이동확정</button>
        <button id="btnMoveCancel" type="button">취소</button>
        <div class="dropdown" id="moveDropdown"></div>
      </div>

      <div class="searchbox" id="searchBox">
        <span class="smallpill" id="searchCountPill">검색: 0</span>
        <input class="search-input" id="searchInput" placeholder="이름/내용 키워드 검색 (Enter)" />
        <button id="btnSearchClear" type="button">지우기</button>
        <button id="btnSearchClose" type="button">닫기</button>
        <div class="dropdown" id="searchDropdown"></div>
      </div>
    </div>
  </div>

  <div class="nav-mini">
    <div class="nav-left">
      <button id="btnUp" type="button">◀ 상위로</button>
      <button id="btnAll" type="button">⬆ 전체로</button>
    </div>
    <div class="nav-right">
      <button class="mode-btn" id="btnBackupMode" type="button">백업모드</button>
      <button class="mode-btn memo" id="btnMemoMode" type="button">메모모드(0개)</button>
      <button class="mode-btn" id="btnEditMode" type="button">편집모드</button>
      <button class="mode-btn" id="btnMoveMode" type="button">이동모드</button>
      <button class="mode-btn" id="btnSearchMode" type="button">검색모드</button>
      <button class="mode-btn" id="btnStatsMode" type="button">통계모드</button>
    </div>
  </div>

  <div class="editpanel" id="editPanel">
    <label>
      버튼 길이
      <input class="range" id="btnWidthRange" type="range" min="10" max="160" step="1" />
      <span class="kv"><span id="btnWidthVal">15</span>%</span>
    </label>
    <span style="font-size:12px; opacity:.65;">※ 편집모드에서만 조절 가능, 모든 버튼에 동일 적용</span>
  </div>

  <div class="backuppanel" id="backupPanel">
    <button id="btnBackupDownload" type="button">백업(파일 저장)</button>
    <button id="btnBackupUpload" type="button">복원(파일 불러오기)</button>
    <input id="backupFileInput" type="file" accept="application/json" style="display:none;" />
    <span class="hintline">※ 백업은 JSON 파일 1개로 저장됩니다. (PC↔모바일 이동 가능)</span>
  </div>

  <div class="crumbbar" id="breadcrumbBar"></div>

  <div class="split" id="split">
    <div class="pane" id="leftPane">
      <div class="scrollWrap" id="leftScrollWrap">
        <div id="buttonContainer"></div>
      </div>

      <div class="addbar">
        <button id="btnAddHere" type="button">+ 새버튼</button>
        <button id="btnAddChildQuick" type="button" title="현재 선택된 버튼의 하위에 추가">+ 하위버튼</button>
      </div>

      <div class="hctrl" id="leftHCtrl">
        <button class="hbtn" id="leftBtnL" type="button">◀</button>
        <div class="htrack" id="leftTrack"><div class="hthumb" id="leftThumb"></div></div>
        <button class="hbtn" id="leftBtnR" type="button">▶</button>
      </div>
    </div>

    <div class="divider" id="divider" title="드래그로 폭 조절"></div>

    <div class="pane" id="rightPane">
      <div class="scrollWrap" id="rightScrollWrap">
        <div class="note-head">
          <div class="note-title">
            내용
            <span class="badge" id="noteForLabel">선택: 전체</span>
            <span class="badge" id="notePathLabel">전체</span>
          </div>
          <div class="note-actions" id="noteActions">
            <button id="btnNoteEdit" type="button">수정</button>
            <button id="btnNoteSave" type="button" style="display:none;">저장</button>
            <button id="btnNoteCancel" type="button" style="display:none;">취소</button>
          </div>
        </div>

        <!-- ✅ (변경) 속성(위) ↔ 내용(아래) 드래그 split -->
        <div class="inner-split" id="rightInnerSplit">
          <!-- 위: 속성/툴바 -->
          <div class="inner-pane" id="propPane">
            <div class="prop-scroll">
              <div class="editor-toolbar">
                <button class="toolbtn" id="toolBold" type="button"><b>B</b></button>
                <button class="toolbtn" id="toolItalic" type="button"><i>I</i></button>
                <button class="toolbtn" id="toolUnderline" type="button"><u>U</u></button>

                <label style="display:flex; align-items:center; gap:6px; font-size:12px;">
                  글자크기
                  <select class="toolselect" id="toolFontSize">
                    <option value="12px">12</option>
                    <option value="13px" selected>13</option>
                    <option value="14px">14</option>
                    <option value="16px">16</option>
                    <option value="18px">18</option>
                    <option value="20px">20</option>
                    <option value="24px">24</option>
                    <option value="28px">28</option>
                  </select>
                </label>

                <label style="display:flex; align-items:center; gap:6px; font-size:12px;">
                  형광색
                  <input class="colorpick" id="toolHighlightColor" type="color" value="#fff59d" />
                </label>
                <button class="toolbtn" id="toolHighlight" type="button">형광펜</button>

                <label style="display:flex; align-items:center; gap:6px; font-size:12px;">
                  글자색
                  <input class="colorpick" id="toolColor" type="color" value="#000000" />
                </label>
                <button class="toolbtn" id="toolTextColor" type="button">글자색</button>

                <!-- ✅ (추가) 표 셀 배경색 -->
                <label style="display:flex; align-items:center; gap:6px; font-size:12px;">
                  배경색
                  <input class="colorpick" id="toolBgColor" type="color" value="#ffffff" />
                </label>
                <button class="toolbtn" id="toolCellBg" type="button">배경색</button>

                <button class="toolbtn" id="toolTable" type="button">표 삽입</button>
                <button class="toolbtn" id="toolMerge" type="button">셀합침</button>
                <button class="toolbtn" id="toolSplit" type="button">셀나눔</button>

                <button class="toolbtn" id="toolAddRow" type="button">행+</button>
                <button class="toolbtn" id="toolDelRow" type="button">행-</button>
                <button class="toolbtn" id="toolAddCol" type="button">열+</button>
                <button class="toolbtn" id="toolDelCol" type="button">열-</button>

                <button class="toolbtn" id="toolEqCol" type="button">열균등</button>
                <button class="toolbtn" id="toolEqRow" type="button">행균등</button>
                <button class="toolbtn" id="toolSplitTable" type="button">표나누기</button>
                <button class="toolbtn" id="toolDelTable" type="button">표삭제</button>

                <label style="display:flex; align-items:center; gap:6px; font-size:12px;">
                  선색
                  <input class="colorpick" id="toolBorderColor" type="color" value="#666666" />
                </label>
                <label style="display:flex; align-items:center; gap:6px; font-size:12px;">
                  선두께
                  <select class="toolselect" id="toolBorderWidth">
                    <option value="1" selected>1</option>
                    <option value="2">2</option>
                    <option value="3">3</option>
                    <option value="4">4</option>
                    <option value="5">5</option>
                  </select>
                </label>
                <button class="toolbtn" id="toolApplyBorder" type="button">선적용</button>

                <button class="toolbtn" id="toolClear" type="button">서식제거</button>
              </div>

              <div class="hint" style="margin:0;">
                ※ 표 배경색은 “현재 선택된 셀” 기준으로 적용됩니다.
              </div>
            </div>
          </div>

          <!-- 드래그 바 -->
          <div class="inner-divider" id="propDivider" title="드래그로 위/아래 높이 조절"></div>

          <!-- 아래: 내용(보기/입력) -->
          <div class="inner-pane" id="contentPane">
            <div class="content-scroll">
              <div class="note-view" id="noteView"></div>

              <div id="editorWrap" style="display:none;">
                <div class="note-editor" id="noteEditor" contenteditable="true"></div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div class="hctrl" id="rightHCtrl">
        <button class="hbtn" id="rightBtnL" type="button">◀</button>
        <div class="htrack" id="rightTrack"><div class="hthumb" id="rightThumb"></div></div>
        <button class="hbtn" id="rightBtnR" type="button">▶</button>
      </div>
    </div>
  </div>
</div>

<!-- ✅ 메모모드 떠있는 창 -->
<div class="memo-window" id="memoWindow" aria-label="메모모드 창">
  <div class="memo-header" id="memoHeader">
    <div class="memo-title">
      메모모드
      <span class="memo-badge" id="memoHeaderCount">0개</span>
      <span class="memo-loc" id="memoHeaderLoc">위치: ROOT</span>
    </div>
    <div class="memo-spacer">
      <button class="memo-close" id="memoClose" type="button">닫기</button>
    </div>
  </div>

  <div class="memo-body">
    <div class="memo-left">
      <textarea class="memo-input" id="memoInput" placeholder="여기에 입력 후 Enter = 저장 / Shift+Enter = 줄바꿈"></textarea>

      <div class="memo-actions">
        <button id="memoAllSelect" type="button">전체 선택</button>
        <button id="memoAllCopy" type="button">전체 복사</button>
        <button id="memoSelCopy" type="button">선택 복사</button>
        <button id="memoSelEdit" type="button">선택 수정</button>
        <button id="memoSelDel" type="button">선택 삭제</button>
      </div>

      <div class="memo-hint" id="memoHint">
여기에 입력 후 Enter (오른쪽 목록에 저장)
Shift+Enter = 줄바꿈
※ 이 창은 드래그로 이동 / 우하단으로 크기 조절 가능
      </div>
    </div>

    <div class="memo-right" id="memoList"></div>
  </div>
</div>

<!-- ✅ 버튼 이름 입력 모달: Enter=확인, Shift+Enter=줄바꿈 -->
<div class="modal-backdrop" id="nameModal">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="nameModalTitle">
    <h3 id="nameModalTitle">버튼 이름 입력</h3>
    <div class="row">
      <label>
        이름 (Enter=확인 / Shift+Enter=줄바꿈)
        <textarea id="nameModalTextarea" placeholder="예) 1줄&#10;2줄&#10;3줄"></textarea>
      </label>
    </div>
    <div class="actions">
      <button id="nameModalCancel" type="button">취소</button>
      <button id="nameModalOk" type="button">확인</button>
    </div>
    <div class="hint">※ 줄바꿈이 포함된 이름도 그대로 저장됩니다.</div>
  </div>
</div>

<!-- ✅ 메모 수정 모달 (✅ 드래그 가능 + 메모창 위로 표시) -->
<div class="modal-backdrop" id="memoEditModal">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="memoEditModalTitle">
    <h3 id="memoEditModalTitle">메모 수정</h3>
    <div class="row">
      <label>
        내용 (Enter=확인 / Shift+Enter=줄바꿈)
        <textarea id="memoEditTextarea" placeholder="메모 내용을 수정하세요"></textarea>
      </label>
    </div>
    <div class="actions">
      <button id="memoEditCancel" type="button">취소</button>
      <button id="memoEditOk" type="button">확인</button>
    </div>
    <div class="hint">※ 한 개만 선택했을 때 수정할 수 있습니다.</div>
  </div>
</div>

<!-- ✅ (추가) 백업 파일명 지정 모달 -->
<div class="modal-backdrop" id="backupNameModal">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="backupNameModalTitle">
    <h3 id="backupNameModalTitle">백업 파일 이름 지정</h3>
    <div class="row">
      <label>
        파일 이름 (.json은 자동으로 붙습니다)
        <input id="backupNameInput" type="text" placeholder="예) 내버튼트리_20260107" />
      </label>
    </div>
    <div class="actions">
      <button id="backupNameCancel" type="button">취소</button>
      <button id="backupNameOk" type="button">확인</button>
    </div>
    <div class="hint">※ Enter=확인 / Esc=취소</div>
  </div>
</div>

<!-- 통계 모달 -->
<div class="modal-backdrop" id="statsModal">
  <div class="modal" role="dialog" aria-modal="true" aria-labelledby="statsModalTitle">
    <h3 id="statsModalTitle">통계</h3>
    <div class="stat-grid">
      <div class="stat-card" id="statLastActionCard" style="display:none;">
        <div class="stat-k" id="statLastActionKey">최근 작업</div>
        <div class="stat-v mono" id="statLastActionVal">-</div>
      </div>

      <div class="stat-card">
        <div class="stat-k">총 버튼 개수 (전체 제외)</div>
        <div class="stat-v mono" id="statTotalButtons">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-k">내용이 있는 버튼 개수 (내용 총 개수)</div>
        <div class="stat-v mono" id="statHasContent">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-k">전체 내용 글자수 (텍스트 기준)</div>
        <div class="stat-v mono" id="statTotalChars">0</div>
      </div>
      <div class="stat-card">
        <div class="stat-k">전체 메모 개수</div>
        <div class="stat-v mono" id="statTotalMemos">0</div>
      </div>
    </div>
    <div class="actions" style="margin-top:12px;">
      <button id="statsClose" type="button">닫기</button>
    </div>
    <div class="hint">※ 글자수는 HTML 서식을 제외한 “텍스트” 기준으로 계산됩니다.</div>
  </div>
</div>

<script>
const $ = (id) => document.getElementById(id);
function onClick(id, fn){
  const el = $(id);
  if (!el) { console.warn("missing element:", id); return; }
  el.addEventListener("click", (e) => {
    try { fn(e); } catch (err) { console.error(err); alert("오류가 발생했어요. (콘솔 확인)"); }
  });
}
function onInput(id, fn){
  const el = $(id);
  if (!el) { console.warn("missing element:", id); return; }
  el.addEventListener("input", (e) => {
    try { fn(e); } catch (err) { console.error(err); }
  });
}

/* ===== Persist keys (✅ 변경 금지: 기존 데이터 유지) ===== */
const PERSIST = {
  LS_KEY: "bokhanareum_button_tree_PERSIST",
  IDB_NAME: "bokhanareum_button_tree_DB",
  IDB_STORE: "kv",
  IDB_DOC_KEY: "state",
};

let state = {
  version: 15,
  updatedAt: 0,
  ui: {
    splitLeftPx: null,
    buttonWidthPct: 15,
    mainButtonPx: null,
    editMode: false,
    backupMode: false,
    searchMode: false,
    moveMode: false,

    /* ✅ (추가) 오른쪽 내부(속성/내용) 분할 높이 */
    propSplitPx: 220,

    /* ✅ 메모 창 상태/좌표/크기 */
    memoOpen: false,
    memoX: 60,
    memoY: 120,
    memoW: 760,
    memoH: 420,
  },
  tree: { id:"root", label:"전체", note:"", noteHtml:null, children:[] },

  /* ✅ 메모 데이터 (기존 clickLog 유지) */
  clickLog: [], // {id, at, text, nodeId}
};

let currentParentId = "root";
let selectedNodeId = "root";
let noteEditMode = false;

/* ✅ 이동모드 상태 */
let moveState = { sourceId: null, targetId: null };

/* ✅ 메모 선택 상태 */
let memoSelected = new Set(); // logId

/* ===========================
   ✅ 이름 모달 (Enter=확인 / Shift+Enter=줄바꿈)
   =========================== */
let nameModalResolve = null;
function openNameModal({ title="버튼 이름 입력", initialValue="" } = {}) {
  $("nameModalTitle").textContent = title;
  const ta = $("nameModalTextarea");
  ta.value = String(initialValue ?? "");
  $("nameModal").classList.add("show");
  setTimeout(() => {
    ta.focus();
    ta.selectionStart = ta.selectionEnd = ta.value.length;
  }, 0);

  return new Promise((resolve) => { nameModalResolve = resolve; });
}
function closeNameModal(value){
  $("nameModal").classList.remove("show");
  const resolve = nameModalResolve;
  nameModalResolve = null;
  if (resolve) resolve(value);
}
function normalizeLabel(raw){
  let s = String(raw ?? "");
  s = s.replace(/\r\n/g, "\n").replace(/\r/g, "\n");
  s = s.split("\n").map(line => line.replace(/[ \t]+$/g, "")).join("\n");
  s = s.trim();
  s = s.replace(/\n{4,}/g, "\n\n\n");
  return s;
}
function bindNameModalEvents(){
  const ta = $("nameModalTextarea");
  onClick("nameModalCancel", () => closeNameModal(null));
  onClick("nameModalOk", () => closeNameModal(normalizeLabel(ta.value)));
  $("nameModal").addEventListener("click", (e) => {
    if (e.target.id === "nameModal") closeNameModal(null);
  });
  ta.addEventListener("keydown", (e) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      closeNameModal(normalizeLabel(ta.value));
    }
  });
}

/* ===========================
   ✅ 메모 수정 모달
   (✅ 수정: 메모창 위 + 드래그 이동)
   =========================== */
let memoEditResolve = null;
function openMemoEditModal({ initialValue="" } = {}){
  const ta = $("memoEditTextarea");
  ta.value = String(initialValue ?? "");
  $("memoEditModal").classList.add("show");

  // ✅ 처음 뜰 때 위치 + 포커스
  setTimeout(() => {
    positionMemoEditModalInitial();
    ta.focus();
    ta.selectionStart = ta.selectionEnd = ta.value.length;
  }, 0);

  return new Promise((resolve) => { memoEditResolve = resolve; });
}
function closeMemoEditModal(val){
  $("memoEditModal").classList.remove("show");
  const r = memoEditResolve;
  memoEditResolve = null;
  if (r) r(val);
}
function bindMemoEditModalEvents(){
  const ta = $("memoEditTextarea");
  onClick("memoEditCancel", () => closeMemoEditModal(null));
  onClick("memoEditOk", () => closeMemoEditModal(normalizeLabel(ta.value)));

  $("memoEditModal").addEventListener("click", (e) => {
    if (e.target.id === "memoEditModal") closeMemoEditModal(null);
  });

  ta.addEventListener("keydown", (e) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      closeMemoEditModal(normalizeLabel(ta.value));
    }
  });
}

/* ===========================
   ✅ (추가) 백업 파일명 모달
   =========================== */
let backupNameResolve = null;
function sanitizeFilename(name){
  name = String(name ?? "").trim();
  name = name.replace(/[\\\/:*?"<>|]+/g, "_");
  name = name.replace(/[ .]+$/g, "");
  return name.trim();
}
function ensureJsonExt(name){
  const n = String(name ?? "");
  return n.toLowerCase().endsWith(".json") ? n : (n + ".json");
}
function openBackupNameModal({ initialValue="" } = {}){
  const input = $("backupNameInput");
  input.value = String(initialValue ?? "");
  $("backupNameModal").classList.add("show");

  setTimeout(() => {
    input.focus();
    input.selectionStart = 0;
    input.selectionEnd = input.value.length;
  }, 0);

  return new Promise((resolve) => { backupNameResolve = resolve; });
}
function closeBackupNameModal(val){
  $("backupNameModal").classList.remove("show");
  const r = backupNameResolve;
  backupNameResolve = null;
  if (r) r(val);
}
function bindBackupNameModalEvents(){
  const input = $("backupNameInput");
  onClick("backupNameCancel", () => closeBackupNameModal(null));
  onClick("backupNameOk", () => closeBackupNameModal(input.value));

  $("backupNameModal").addEventListener("click", (e) => {
    if (e.target.id === "backupNameModal") closeBackupNameModal(null);
  });

  input.addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      closeBackupNameModal(input.value);
    } else if (e.key === "Escape") {
      e.preventDefault();
      closeBackupNameModal(null);
    }
  });
}

/* ===== IndexedDB ===== */
function idbOpen() {
  return new Promise((resolve, reject) => {
    const req = indexedDB.open(PERSIST.IDB_NAME, 1);
    req.onupgradeneeded = () => {
      const db = req.result;
      if (!db.objectStoreNames.contains(PERSIST.IDB_STORE)) db.createObjectStore(PERSIST.IDB_STORE);
    };
    req.onsuccess = () => resolve(req.result);
    req.onerror = () => reject(req.error);
  });
}
async function idbGet(key) {
  const db = await idbOpen();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(PERSIST.IDB_STORE, "readonly");
    const store = tx.objectStore(PERSIST.IDB_STORE);
    const req = store.get(key);
    req.onsuccess = () => resolve(req.result ?? null);
    req.onerror = () => reject(req.error);
    tx.oncomplete = () => db.close();
  });
}
async function idbSet(key, value) {
  const db = await idbOpen();
  return new Promise((resolve, reject) => {
    const tx = db.transaction(PERSIST.IDB_STORE, "readwrite");
    const store = tx.objectStore(PERSIST.IDB_STORE);
    const req = store.put(value, key);
    req.onsuccess = () => resolve(true);
    req.onerror = () => reject(req.error);
    tx.oncomplete = () => db.close();
  });
}

/* ===== Persist helpers ===== */
function ensureNodeFields(node){
  if (!node) return;
  if (typeof node.note !== "string") node.note = "";
  if (typeof node.noteHtml !== "string" && node.noteHtml !== null) node.noteHtml = null;
  if (!Array.isArray(node.children)) node.children = [];
  if (typeof node.label !== "string") node.label = "";
  for (const c of node.children) ensureNodeFields(c);
}
function migrateRootLabel(tree){ if (tree && tree.id === "root") tree.label = "전체"; }

/* ✅ 메모 보정 */
function ensureMemoFields(){
  if (!Array.isArray(state.clickLog)) state.clickLog = [];
  state.clickLog = state.clickLog
    .filter(x => x && typeof x === "object")
    .map(x => ({
      id: String(x.id || genId()),
      at: Number.isFinite(x.at) ? x.at : Date.now(),
      text: String(x.text ?? ""),
      nodeId: String(x.nodeId || "root"),
    }));
}

async function persistState(){
  state.updatedAt = Date.now();
  try { localStorage.setItem(PERSIST.LS_KEY, JSON.stringify(state)); } catch {}
  try { await idbSet(PERSIST.IDB_DOC_KEY, state); } catch {}
}
async function loadState(){
  let from = null;
  try { from = await idbGet(PERSIST.IDB_DOC_KEY); } catch {}
  if (!from) {
    try {
      const raw = localStorage.getItem(PERSIST.LS_KEY);
      from = raw ? JSON.parse(raw) : null;
    } catch {}
  }
  if (from && from.tree) {
    state = { ...state, ...from, ui: { ...state.ui, ...(from.ui||{}) } };
  }
  ensureNodeFields(state.tree);
  migrateRootLabel(state.tree);
  ensureMemoFields();

  // ✅ 새 값 기본 보정
  if (!Number.isFinite(state.ui.propSplitPx)) state.ui.propSplitPx = 220;

  await persistState();
}

/* ===========================
   ✅ 백업/복원 (파일 1개 JSON)
   =========================== */
function makeBackupFilename(){
  const d = new Date();
  const pad = (n)=> String(n).padStart(2,"0");
  const ts = d.getFullYear()
    + pad(d.getMonth()+1)
    + pad(d.getDate())
    + "_" + pad(d.getHours()) + pad(d.getMinutes()) + pad(d.getSeconds());
  return "bokhanareum_backup_" + ts + ".json";
}
function buildBackupObject(){
  return {
    backupFormat: "bokhanareum_button_tree_v1",
    exportedAt: Date.now(),
    payload: state
  };
}
let lastBackupRestoreInfo = null; // { type:"backup"|"restore", at:number }

async function doBackupDownload(){
  try{
    await persistState();

    const defaultBase = makeBackupFilename().replace(/\.json$/i, "");
    const rawName = await openBackupNameModal({ initialValue: defaultBase });
    if (rawName === null) return;

    let clean = sanitizeFilename(rawName);
    if (!clean) clean = defaultBase;
    const filename = ensureJsonExt(clean);

    const obj = buildBackupObject();
    const json = JSON.stringify(obj, null, 2);
    const blob = new Blob([json], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=> URL.revokeObjectURL(url), 5000);

    lastBackupRestoreInfo = { type: "backup", at: Date.now() };
    openStatsModal("backup");

    alert("백업 파일이 다운로드되었습니다.\n(다운로드 폴더에서 확인하세요)");
  }catch(err){
    console.error(err);
    alert("백업 중 오류가 발생했습니다. (콘솔 확인)");
  }
}
async function applyRestoredState(restored){
  if (!restored || !restored.tree) throw new Error("invalid backup: missing tree");
  state = { ...state, ...restored, ui: { ...state.ui, ...(restored.ui||{}) } };
  ensureNodeFields(state.tree);
  migrateRootLabel(state.tree);
  ensureMemoFields();

  if (!Number.isFinite(state.ui.propSplitPx)) state.ui.propSplitPx = 220;

  currentParentId = "root";
  selectedNodeId = "root";
  noteEditMode = false;
  memoSelected.clear();

  ensureMainButtonPx();
  applySplitFromState();
  applyMemoWindowFromState();
  applyPropSplitFromState();

  await persistState();
  syncModeButtons();
  render();

  lastBackupRestoreInfo = { type: "restore", at: Date.now() };
  openStatsModal("restore");
}
async function doBackupRestoreFromFile(file){
  if (!file) return;
  try{
    const text = await file.text();
    const obj = JSON.parse(text);
    const payload = (obj && obj.payload && obj.payload.tree) ? obj.payload : obj;

    const ok = confirm(
      "복원을 실행하면 현재 기기(브라우저)에 저장된 데이터가\n"
      + "백업 파일의 데이터로 '덮어쓰기' 됩니다.\n\n"
      + "계속할까요?"
    );
    if (!ok) return;

    await applyRestoredState(payload);
    alert("복원이 완료되었습니다.");
  }catch(err){
    console.error(err);
    alert("복원 실패: 백업 파일이 올바르지 않거나 손상되었습니다.");
  }
}

/* ===== Tree utils ===== */
function genId(){ return "id_" + Date.now().toString(36) + "_" + Math.random().toString(36).slice(2,10); }
function findNodeById(node,id){
  if (!node) return null;
  if (node.id === id) return node;
  for (const c of (node.children||[])){ const f = findNodeById(c,id); if (f) return f; }
  return null;
}
function findParentNode(root,targetId){
  if (!root) return null;
  for (const c of (root.children||[])){
    if (c.id === targetId) return root;
    const f = findParentNode(c,targetId);
    if (f) return f;
  }
  return null;
}
function getCurrentParentNode(){
  const node = findNodeById(state.tree,currentParentId);
  if (!node) currentParentId = "root";
  return node || state.tree;
}
function getPathToId(targetId){
  const path = [];
  function dfs(n){
    path.push(n);
    if (n.id === targetId) return true;
    for (const c of (n.children||[])) if (dfs(c)) return true;
    path.pop(); return false;
  }
  dfs(state.tree);
  return path.length ? path : [state.tree];
}
function getPathToCurrent(){ return (currentParentId==="root") ? [state.tree] : getPathToId(currentParentId); }

/* ===== Stats ===== */
function countButtonsAndContent(){
  let totalButtons = 0;
  let hasContent = 0;
  let totalChars = 0;

  function dfs(node){
    if (!node) return;
    if (node.id !== "root") totalButtons++;

    const text = (node.note || "").trim();
    if (text.length > 0){
      hasContent++;
      totalChars += text.length;
    }
    for (const c of (node.children||[])) dfs(c);
  }
  dfs(state.tree);
  return { totalButtons, hasContent, totalChars };
}
function openStatsModal(context = null){
  const { totalButtons, hasContent, totalChars } = countButtonsAndContent();
  $("statTotalButtons").textContent = String(totalButtons);
  $("statHasContent").textContent = String(hasContent);
  $("statTotalChars").textContent = String(totalChars);
  $("statTotalMemos").textContent = String((state.clickLog||[]).length);

  const card = $("statLastActionCard");
  const keyEl = $("statLastActionKey");
  const valEl = $("statLastActionVal");

  if (context === "backup"){
    card.style.display = "";
    keyEl.textContent = "최근 작업";
    valEl.textContent = "백업됨";
  } else if (context === "restore"){
    card.style.display = "";
    keyEl.textContent = "최근 작업";
    valEl.textContent = "복원됨";
  } else {
    if (lastBackupRestoreInfo && lastBackupRestoreInfo.type){
      card.style.display = "";
      keyEl.textContent = "최근 작업";
      valEl.textContent = (lastBackupRestoreInfo.type === "backup") ? "백업됨" : "복원됨";
    } else {
      card.style.display = "none";
    }
  }

  $("statsModal").classList.add("show");
}
function closeStatsModal(){ $("statsModal").classList.remove("show"); }
function bindStatsEvents(){
  onClick("btnStatsMode", () => openStatsModal());
  onClick("statsClose", () => closeStatsModal());
  $("statsModal").addEventListener("click", (e) => {
    if (e.target.id === "statsModal") closeStatsModal();
  });
}

/* ===== Split (pane) ===== */
function applySplitFromState(){
  const left = $("leftPane");
  const split = $("split");
  if (!left || !split) return;
  const total = split.clientWidth;
  let px = state.ui.splitLeftPx;
  if (typeof px !== "number" || isNaN(px)) px = Math.floor(total * 0.5);
  px = Math.max(0, Math.min(total, px));
  left.style.width = px + "px";
}
function bindSplitDrag(){
  const divider = $("divider");
  const split = $("split");
  const left = $("leftPane");
  if (!divider || !split || !left) return;

  let dragging = false;
  divider.addEventListener("pointerdown", (e) => {
    dragging = true;
    divider.setPointerCapture?.(e.pointerId);
    e.preventDefault();
  });
  window.addEventListener("pointermove", async (e) => {
    if (!dragging) return;
    const rect = split.getBoundingClientRect();
    const x = e.clientX - rect.left;
    state.ui.splitLeftPx = Math.max(0, Math.min(split.clientWidth, Math.floor(x)));
    left.style.width = state.ui.splitLeftPx + "px";
    await persistState();
  });
  window.addEventListener("pointerup", () => { dragging = false; });
}

/* ✅✅✅ 오른쪽 내부 split(속성/내용) 위아래 드래그 */
function applyPropSplitFromState(){
  const split = $("rightInnerSplit");
  const prop = $("propPane");
  if (!split || !prop) return;

  const total = split.clientHeight;
  let px = state.ui.propSplitPx;
  if (typeof px !== "number" || isNaN(px)) px = 220;

  const minPx = 80;
  const maxPx = Math.max(minPx, Math.floor(total - 120));
  px = Math.max(minPx, Math.min(maxPx, px));

  prop.style.height = px + "px";
  state.ui.propSplitPx = px;
}
function bindPropSplitDrag(){
  const divider = $("propDivider");
  const split = $("rightInnerSplit");
  if (!divider || !split) return;

  let dragging = false;

  divider.addEventListener("pointerdown", (e) => {
    dragging = true;
    divider.setPointerCapture?.(e.pointerId);
    e.preventDefault();
  });

  window.addEventListener("pointermove", async (e) => {
    if (!dragging) return;
    const rect = split.getBoundingClientRect();
    const y = e.clientY - rect.top;
    state.ui.propSplitPx = Math.floor(y);
    applyPropSplitFromState();
    await persistState();
  });

  window.addEventListener("pointerup", () => { dragging = false; });
  window.addEventListener("resize", () => applyPropSplitFromState());
}

/* ===== Horizontal controls ===== */
function bindHCtrl(side){
  const wrap = $(side==="left" ? "leftScrollWrap" : "rightScrollWrap");
  const btnL = $(side==="left" ? "leftBtnL" : "rightBtnL");
  const btnR = $(side==="left" ? "leftBtnR" : "rightBtnR");
  const track = $(side==="left" ? "leftTrack" : "rightTrack");
  const thumb = $(side==="left" ? "leftThumb" : "rightThumb");
  if (!wrap || !btnL || !btnR || !track || !thumb) return;

  const step = 180;

  btnL.onclick = () => { wrap.scrollLeft -= step; syncThumb(); };
  btnR.onclick = () => { wrap.scrollLeft += step; syncThumb(); };

  function syncThumb(){
    const max = Math.max(1, wrap.scrollWidth - wrap.clientWidth);
    const ratio = wrap.scrollLeft / max;
    const trackW = track.clientWidth;
    const thumbW = Math.min(80, Math.max(44, Math.floor(trackW * 0.25)));
    thumb.style.width = thumbW + "px";
    const maxX = Math.max(0, trackW - thumbW);
    thumb.style.left = Math.floor(maxX * ratio) + "px";
    btnL.disabled = wrap.scrollLeft <= 0;
    btnR.disabled = wrap.scrollLeft >= max - 1;
  }

  let dragging = false;
  let startX = 0;
  let startLeft = 0;

  thumb.addEventListener("pointerdown", (e) => {
    dragging = true;
    startX = e.clientX;
    startLeft = parseFloat(getComputedStyle(thumb).left) || 0;
    thumb.setPointerCapture?.(e.pointerId);
    e.preventDefault();
  });
  window.addEventListener("pointermove", (e) => {
    if (!dragging) return;
    const trackW = track.clientWidth;
    const thumbW = thumb.clientWidth || 44;
    const maxX = Math.max(0, trackW - thumbW);
    const dx = e.clientX - startX;
    let nx = Math.max(0, Math.min(maxX, startLeft + dx));
    thumb.style.left = nx + "px";
    const ratio = maxX ? (nx / maxX) : 0;
    const maxScroll = Math.max(1, wrap.scrollWidth - wrap.clientWidth);
    wrap.scrollLeft = Math.floor(maxScroll * ratio);
    btnL.disabled = wrap.scrollLeft <= 0;
    btnR.disabled = wrap.scrollLeft >= maxScroll - 1;
  });
  window.addEventListener("pointerup", () => { dragging = false; });

  wrap.addEventListener("scroll", syncThumb);
  window.addEventListener("resize", syncThumb);
  setTimeout(syncThumb, 0);
}

/* ===== UI ===== */
function computeMainButtonPxFromCurrentVisible(){
  const wrap = $("leftScrollWrap");
  const split = $("split");
  const pad = parseFloat(getComputedStyle(split).getPropertyValue("--panePad")) || 0;
  const visible = Math.max(160, Math.floor(wrap.clientWidth - pad * 2));
  const pct = Math.max(10, Math.min(160, Number(state.ui.buttonWidthPct || 15)));
  return Math.max(60, Math.floor(visible * (pct / 100)));
}
function ensureMainButtonPx(){
  if (typeof state.ui.mainButtonPx === "number" && state.ui.mainButtonPx > 0) return;
  state.ui.mainButtonPx = computeMainButtonPxFromCurrentVisible();
}
function syncModeButtons(){
  $("btnEditMode").classList.toggle("active", !!state.ui.editMode);
  $("btnBackupMode").classList.toggle("active", !!state.ui.backupMode);
  $("btnMoveMode")?.classList.toggle("active", !!state.ui.moveMode);
  $("btnSearchMode")?.classList.toggle("active", !!state.ui.searchMode);

  $("editPanel").classList.toggle("show", !!state.ui.editMode);
  $("backupPanel")?.classList.toggle("show", !!state.ui.backupMode);

  $("btnWidthRange").value = String(state.ui.buttonWidthPct);
  $("btnWidthVal").textContent = String(state.ui.buttonWidthPct);

  $("moveBox").classList.toggle("show", !!state.ui.moveMode);
  $("searchBox").classList.toggle("show", !!state.ui.searchMode);

  renderMemoButtonCount();
}

/* ===== Breadcrumb ===== */
function renderBreadcrumb(){
  const bar = $("breadcrumbBar");
  const path = getPathToCurrent();
  bar.innerHTML = "";

  path.forEach((node, idx) => {
    const chip = document.createElement("button");
    chip.type = "button";
    chip.className = "crumb-chip" + (idx === path.length-1 ? " active" : "");
    chip.textContent = node.label || (node.id === "root" ? "전체" : "(이름없음)");
    chip.onclick = async () => {
      currentParentId = node.id;
      selectedNodeId = node.id;
      noteEditMode = false;
      memoSelected.clear();
      await persistState();
      render();
    };
    bar.appendChild(chip);

    if (idx !== path.length-1){
      const sep = document.createElement("span");
      sep.className = "crumb-sep";
      sep.textContent = "›";
      bar.appendChild(sep);
    }
  });
}

/* ===== Move mode ===== */
function setMoveMode(on){
  state.ui.moveMode = !!on;
  if (!state.ui.moveMode){
    moveState.sourceId = null;
    moveState.targetId = null;
    $("moveSearchInput").value = "";
    hideMoveDropdown();
  }
  updateMovePills();
  syncModeButtons();
}
function updateMovePills(){
  const s = moveState.sourceId ? (findNodeById(state.tree, moveState.sourceId)?.label || "(없음)") : "-";
  const t = moveState.targetId ? (findNodeById(state.tree, moveState.targetId)?.label || "(없음)") : "-";
  $("movePillSource").textContent = "출발: " + s.replace(/\n/g, " / ");
  $("movePillTarget").textContent = "대상: " + t.replace(/\n/g, " / ");
  $("btnMoveConfirm").disabled = !(moveState.sourceId && moveState.targetId && moveState.sourceId !== moveState.targetId);
}
function hideMoveDropdown(){ $("moveDropdown").classList.remove("show"); $("moveDropdown").innerHTML=""; }
function showMoveDropdown(){ $("moveDropdown").classList.add("show"); }

function listAllNodes(){
  const out = [];
  function dfs(n, path){
    const name = (n.label || (n.id==="root"?"전체":"(이름없음)")).replace(/\n/g," / ");
    const p = path ? (path + " › " + name) : name;
    out.push({ id:n.id, label:name, path:p });
    for (const c of (n.children||[])) dfs(c, p);
  }
  dfs(state.tree, "");
  return out;
}
function runMoveTargetSearch(q){
  q = String(q||"").trim().toLowerCase();
  const dd = $("moveDropdown");
  dd.innerHTML = "";
  if (!q){ hideMoveDropdown(); return; }

  const all = listAllNodes().filter(x => x.id !== "root" && x.id !== moveState.sourceId);
  const hits = all.filter(x => x.label.toLowerCase().includes(q) || x.path.toLowerCase().includes(q)).slice(0, 80);
  if (hits.length === 0){
    const div = document.createElement("div");
    div.className="empty-text";
    div.textContent="검색 결과가 없습니다.";
    dd.appendChild(div);
    showMoveDropdown();
    return;
  }
  hits.forEach(item => {
    const row = document.createElement("div");
    row.className="res-item";
    const title = document.createElement("div");
    title.className="res-title";
    title.textContent=item.label;
    const path = document.createElement("div");
    path.className="res-path";
    path.textContent=item.path;
    const tag = document.createElement("div");
    tag.className="res-tag";
    tag.textContent="선택";
    row.appendChild(title);
    row.appendChild(tag);
    row.appendChild(path);
    row.onclick = () => {
      moveState.targetId = item.id;
      hideMoveDropdown();
      updateMovePills();
    };
    dd.appendChild(row);
  });
  showMoveDropdown();
}

async function executeMove(){
  if (!moveState.sourceId || !moveState.targetId) return;
  if (moveState.sourceId === moveState.targetId) return;

  const sourceParent = findParentNode(state.tree, moveState.sourceId);
  const targetNode = findNodeById(state.tree, moveState.targetId);
  const sourceNode = findNodeById(state.tree, moveState.sourceId);
  if (!sourceParent || !targetNode || !sourceNode) return;

  const targetPath = getPathToId(moveState.targetId).map(x=>x.id);
  if (targetPath.includes(moveState.sourceId)){
    alert("하위로 이동할 수 없습니다. (순환 구조 방지)");
    return;
  }

  sourceParent.children = (sourceParent.children||[]).filter(x => x.id !== moveState.sourceId);
  if (!Array.isArray(targetNode.children)) targetNode.children = [];
  targetNode.children.push(sourceNode);

  setMoveMode(false);
  currentParentId = targetNode.id;
  selectedNodeId = sourceNode.id;

  await persistState();
  render();
}

/* ===== Search mode ===== */
let searchResults = [];
function setSearchMode(on){
  state.ui.searchMode = !!on;
  if (!state.ui.searchMode){
    $("searchInput").value="";
    $("searchCountPill").textContent="검색: 0";
    hideSearchDropdown();
  }
  syncModeButtons();
}
function hideSearchDropdown(){ $("searchDropdown").classList.remove("show"); $("searchDropdown").innerHTML=""; }
function showSearchDropdown(){ $("searchDropdown").classList.add("show"); }
function runSearch(q){
  q = String(q||"").trim().toLowerCase();
  searchResults = [];
  if (!q){
    $("searchCountPill").textContent="검색: 0";
    hideSearchDropdown();
    return;
  }

  const all = listAllNodes();
  function getText(node){
    const t = String(node.note||"");
    const lbl = String(node.label||"");
    return (lbl + "\n" + t).toLowerCase();
  }

  const hits = [];
  for (const item of all){
    const node = findNodeById(state.tree, item.id);
    if (!node) continue;
    if (getText(node).includes(q)) hits.push(item);
  }
  searchResults = hits.slice(0, 120);
  $("searchCountPill").textContent="검색: " + String(hits.length);

  const dd = $("searchDropdown");
  dd.innerHTML = "";

  if (searchResults.length === 0){
    const div = document.createElement("div");
    div.className="empty-text";
    div.textContent="검색 결과가 없습니다.";
    dd.appendChild(div);
    showSearchDropdown();
    return;
  }

  searchResults.forEach(item => {
    const row = document.createElement("div");
    row.className="res-item";
    const title = document.createElement("div");
    title.className="res-title";
    title.textContent=item.label;
    const path = document.createElement("div");
    path.className="res-path";
    path.textContent=item.path;
    const tag = document.createElement("div");
    tag.className="res-tag";
    tag.textContent="이동";
    row.appendChild(title);
    row.appendChild(tag);
    row.appendChild(path);
    row.onclick = async () => {
      currentParentId = item.id;
      selectedNodeId = item.id;
      noteEditMode = false;
      memoSelected.clear();
      hideSearchDropdown();
      await persistState();
      render();
    };
    dd.appendChild(row);
  });
  showSearchDropdown();
}

/* ===== Note panel / Editor tools ===== */
function escapeHtml(str){
  return String(str ?? "").replace(/[&<>"']/g, s => ({
    "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
  }[s]));
}
function renderNotePanel(){
  const node = findNodeById(state.tree, selectedNodeId) || state.tree;
  $("noteForLabel").textContent = "선택: " + (node.label || (node.id==="root"?"전체":"(이름없음)")).replace(/\n/g," / ");

  const path = getPathToId(node.id).map(n => (n.label || (n.id==="root"?"전체":"(이름없음)")).replace(/\n/g," / ")).join(" › ");
  $("notePathLabel").textContent = path;

  const view = $("noteView");
  const editorWrap = $("editorWrap");
  const editor = $("noteEditor");

  $("btnNoteEdit").style.display = noteEditMode ? "none" : "";
  $("btnNoteSave").style.display = noteEditMode ? "" : "none";
  $("btnNoteCancel").style.display = noteEditMode ? "" : "none";

  // ✅ 툴바/속성칸은 "편집 중"일 때만 쓰는 게 자연스럽지만,
  // 사용자가 드래그로 높이 조절을 원하므로 항상 보여주되,
  // 편집 아닐 때는 에디터만 숨김/보기만 표시.
  if (!noteEditMode){
    editorWrap.style.display = "none";
    view.style.display = "";
    const html = (typeof node.noteHtml === "string" && node.noteHtml.trim())
      ? node.noteHtml
      : null;
    if (html){
      view.innerHTML = html;
    } else {
      const t = (node.note || "").trim();
      view.innerHTML = t ? escapeHtml(t).replace(/\n/g,"<br/>") : '<span class="note-empty">내용이 없습니다.</span>';
    }
    return;
  }

  view.style.display = "none";
  editorWrap.style.display = "";
  editor.innerHTML = (typeof node.noteHtml === "string" && node.noteHtml !== null)
    ? node.noteHtml
    : escapeHtml(node.note || "").replace(/\n/g,"<br/>");
}

/* ===== Editor command helpers ===== */
function exec(cmd, value=null){ document.execCommand(cmd, false, value); }
function getSelectedCell(){
  const sel = window.getSelection();
  if (!sel || sel.rangeCount === 0) return null;
  let node = sel.anchorNode;
  if (!node) return null;
  if (node.nodeType === 3) node = node.parentNode;
  while (node && node !== $("noteEditor")){
    if (node.tagName === "TD" || node.tagName === "TH") return node;
    node = node.parentNode;
  }
  return null;
}
function findTableFromCell(cell){
  let n = cell;
  while (n && n !== $("noteEditor")){
    if (n.tagName === "TABLE") return n;
    n = n.parentNode;
  }
  return null;
}
function getCellPos(cell){
  const row = cell.parentElement;
  const table = findTableFromCell(cell);
  if (!row || !table) return null;
  const rows = Array.from(table.rows);
  const r = rows.indexOf(row);
  const cells = Array.from(row.cells);
  const c = cells.indexOf(cell);
  return { table, row, r, c };
}
function safeInt(v, fallback){ v = parseInt(v,10); return Number.isFinite(v) ? v : fallback; }

function insertTable(rows, cols){
  rows = Math.max(1, safeInt(rows, 2));
  cols = Math.max(1, safeInt(cols, 2));
  const table = document.createElement("table");
  const tbody = document.createElement("tbody");
  table.appendChild(tbody);
  for (let r=0;r<rows;r++){
    const tr = document.createElement("tr");
    for (let c=0;c<cols;c++){
      const td = document.createElement("td");
      td.innerHTML = "&nbsp;";
      tr.appendChild(td);
    }
    tbody.appendChild(tr);
  }
  const sel = window.getSelection();
  if (!sel || sel.rangeCount===0) { $("noteEditor").appendChild(table); return; }
  const range = sel.getRangeAt(0);
  range.deleteContents();
  range.insertNode(table);
}
function mergeCells(){
  const cell = getSelectedCell();
  if (!cell) return alert("셀을 선택해주세요.");
  const next = cell.nextElementSibling;
  if (!next) return alert("오른쪽 셀이 없습니다.");
  const cs1 = safeInt(cell.getAttribute("colspan"), 1);
  const cs2 = safeInt(next.getAttribute("colspan"), 1);
  cell.setAttribute("colspan", String(cs1 + cs2));
  cell.innerHTML = (cell.innerHTML || "&nbsp;") + " " + (next.innerHTML || "");
  next.remove();
}
function splitCell(){
  const cell = getSelectedCell();
  if (!cell) return alert("셀을 선택해주세요.");
  const cs = safeInt(cell.getAttribute("colspan"), 1);
  if (cs <= 1) return alert("나눌 수 있는 colspan이 없습니다.");
  cell.setAttribute("colspan", "1");
  const row = cell.parentElement;
  for (let i=0;i<cs-1;i++){
    const td = document.createElement(cell.tagName.toLowerCase());
    td.innerHTML="&nbsp;";
    row.insertBefore(td, cell.nextElementSibling);
  }
}
function addRow(delta){
  const cell = getSelectedCell();
  if (!cell) return alert("셀을 선택해주세요.");
  const pos = getCellPos(cell);
  if (!pos) return;
  const { table, r } = pos;
  const cols = table.rows[r].cells.length;
  if (delta > 0){
    const tr = table.insertRow(r+1);
    for (let i=0;i<cols;i++){
      const td = tr.insertCell(-1);
      td.innerHTML="&nbsp;";
    }
  }else{
    if (table.rows.length <= 1) return alert("더 이상 삭제할 수 없습니다.");
    table.deleteRow(r);
  }
}
function addCol(delta){
  const cell = getSelectedCell();
  if (!cell) return alert("셀을 선택해주세요.");
  const pos = getCellPos(cell);
  if (!pos) return;
  const { table, c } = pos;
  const rows = Array.from(table.rows);
  if (delta > 0){
    rows.forEach(tr => {
      const td = tr.insertCell(c+1);
      td.innerHTML="&nbsp;";
    });
  }else{
    if (rows[0].cells.length <= 1) return alert("더 이상 삭제할 수 없습니다.");
    rows.forEach(tr => tr.deleteCell(c));
  }
}
function equalizeCols(){
  const cell = getSelectedCell();
  if (!cell) return alert("셀을 선택해주세요.");
  const table = findTableFromCell(cell);
  if (!table) return;
  const cols = table.rows[0].cells.length;
  const w = Math.max(48, Math.floor(480 / Math.max(1, cols)));
  Array.from(table.rows).forEach(tr => {
    Array.from(tr.cells).forEach(td => td.style.minWidth = w + "px");
  });
}
function equalizeRows(){
  const cell = getSelectedCell();
  if (!cell) return alert("셀을 선택해주세요.");
  const table = findTableFromCell(cell);
  if (!table) return;
  Array.from(table.rows).forEach(tr => tr.style.height = "auto");
}
function splitTable(){
  const cell = getSelectedCell();
  if (!cell) return alert("셀을 선택해주세요.");
  const pos = getCellPos(cell);
  if (!pos) return;
  const { table, r } = pos;
  if (r <= 0 || r >= table.rows.length) return alert("나눌 위치가 올바르지 않습니다.");

  const newTable = table.cloneNode(false);
  const newBody = document.createElement("tbody");
  newTable.appendChild(newBody);

  const rows = Array.from(table.rows);
  const move = rows.slice(r);
  move.forEach(tr => newBody.appendChild(tr));
  table.parentNode.insertBefore(newTable, table.nextSibling);
}
function deleteTable(){
  const cell = getSelectedCell();
  if (!cell) return alert("셀을 선택해주세요.");
  const table = findTableFromCell(cell);
  if (!table) return;
  if (!confirm("표를 삭제할까요?")) return;
  table.remove();
}
function applyBorder(){
  const cell = getSelectedCell();
  if (!cell) return alert("셀을 선택해주세요.");
  const table = findTableFromCell(cell);
  if (!table) return alert("표 안에서 사용해주세요.");
  const color = $("toolBorderColor").value || "#666666";
  const width = $("toolBorderWidth").value || "1";
  Array.from(table.querySelectorAll("td,th")).forEach(td => {
    td.style.borderColor = color;
    td.style.borderWidth = width + "px";
    td.style.borderStyle = "solid";
  });
}

/* ✅ (추가) 셀 배경색 적용 */
function applyCellBg(){
  const cell = getSelectedCell();
  if (!cell) return alert("배경색을 바꾸려면 표의 셀을 먼저 클릭(선택)하세요.");
  const color = $("toolBgColor").value || "#ffffff";
  cell.style.backgroundColor = color;
}

function bindEditorTools(){
  onClick("toolBold", () => exec("bold"));
  onClick("toolItalic", () => exec("italic"));
  onClick("toolUnderline", () => exec("underline"));

  $("toolFontSize").addEventListener("change", (e) => {
    const size = e.target.value || "13px";
    exec("fontSize", "7");
    const editor = $("noteEditor");
    editor.querySelectorAll('font[size="7"]').forEach(el => {
      el.removeAttribute("size");
      el.style.fontSize = size;
    });
  });

  onClick("toolHighlight", () => {
    const c = $("toolHighlightColor").value || "#fff59d";
    exec("hiliteColor", c);
  });

  onClick("toolTextColor", () => {
    const c = $("toolColor").value || "#000000";
    exec("foreColor", c);
  });

  // ✅ (추가) 셀 배경색
  onClick("toolCellBg", () => applyCellBg());

  onClick("toolTable", async () => {
    const r = prompt("행 개수?", "2");
    if (r === null) return;
    const c = prompt("열 개수?", "2");
    if (c === null) return;
    insertTable(safeInt(r,2), safeInt(c,2));
  });

  onClick("toolMerge", () => mergeCells());
  onClick("toolSplit", () => splitCell());

  onClick("toolAddRow", () => addRow(+1));
  onClick("toolDelRow", () => addRow(-1));
  onClick("toolAddCol", () => addCol(+1));
  onClick("toolDelCol", () => addCol(-1));

  onClick("toolEqCol", () => equalizeCols());
  onClick("toolEqRow", () => equalizeRows());
  onClick("toolSplitTable", () => splitTable());
  onClick("toolDelTable", () => deleteTable());

  onClick("toolApplyBorder", () => applyBorder());
  onClick("toolClear", () => exec("removeFormat"));
}

/* =========================================================
   ✅ 메모모드 기능
   ========================================================= */
function formatKoreanDateTime(ts){
  try{
    const d = new Date(ts);
    return d.toLocaleString("ko-KR", {
      year:"numeric", month:"numeric", day:"numeric",
      hour:"numeric", minute:"2-digit", second:"2-digit"
    });
  }catch{
    return String(ts);
  }
}
function getSelectedLabelForMemo(){
  const node = findNodeById(state.tree, selectedNodeId) || state.tree;
  const label = (node.label || (node.id==="root"?"ROOT":"(이름없음)")).replace(/\n/g," / ");
  return { nodeId: node.id, label };
}
function getMemosForCurrentLocation(){
  const { nodeId } = getSelectedLabelForMemo();
  const all = Array.isArray(state.clickLog) ? state.clickLog : [];
  return all.filter(x => x.nodeId === nodeId).sort((a,b)=>b.at-a.at);
}
async function safeCopyText(text){
  text = String(text ?? "");
  try{
    await navigator.clipboard.writeText(text);
    return true;
  }catch{
    try{
      const ta = document.createElement("textarea");
      ta.value = text;
      ta.style.position="fixed";
      ta.style.left="-9999px";
      document.body.appendChild(ta);
      ta.focus();
      ta.select();
      document.execCommand("copy");
      ta.remove();
      return true;
    }catch{
      return false;
    }
  }
}
function buildCopyTextFromMemos(memos){
  return memos.map(x => {
    const dt = formatKoreanDateTime(x.at);
    return `${dt}\n[입력] ${x.text}`.trim();
  }).join("\n\n");
}
function renderMemoButtonCount(){
  const cnt = (state.clickLog||[]).length;
  $("btnMemoMode").textContent = `메모모드(${cnt}개)`;
  $("memoHeaderCount").textContent = `${cnt}개`;
}
function applyMemoWindowFromState(){
  const w = $("memoWindow");
  if (!w) return;

  const clamp = (v, min, max) => Math.max(min, Math.min(max, v));
  const vw = Math.max(320, window.innerWidth - 24);
  const vh = Math.max(240, window.innerHeight - 24);

  const x = clamp(Number(state.ui.memoX ?? 60), 0, vw - 80);
  const y = clamp(Number(state.ui.memoY ?? 120), 0, vh - 80);
  const mw = clamp(Number(state.ui.memoW ?? 760), 320, vw);
  const mh = clamp(Number(state.ui.memoH ?? 420), 240, vh);

  w.style.left = x + "px";
  w.style.top = y + "px";
  w.style.width = mw + "px";
  w.style.height = mh + "px";

  w.classList.toggle("show", !!state.ui.memoOpen);
}
function openMemoWindow(){
  state.ui.memoOpen = true;
  applyMemoWindowFromState();
  renderMemoWindow();
  persistState();
}
function closeMemoWindow(){
  state.ui.memoOpen = false;
  $("memoWindow").classList.remove("show");
  persistState();
}
function toggleMemoWindow(){
  state.ui.memoOpen = !state.ui.memoOpen;
  applyMemoWindowFromState();
  if (state.ui.memoOpen) renderMemoWindow();
  persistState();
}
function renderMemoWindow(){
  ensureMemoFields();
  renderMemoButtonCount();

  const { label, nodeId } = getSelectedLabelForMemo();
  $("memoHeaderLoc").textContent = `위치: ${nodeId === "root" ? "ROOT" : label}`;

  const memos = getMemosForCurrentLocation();

  const list = $("memoList");
  list.innerHTML = "";

  if (memos.length === 0){
    const div = document.createElement("div");
    div.className = "empty-text";
    div.textContent = "이 위치의 메모가 없습니다.\n왼쪽 입력칸에 입력 후 Enter로 저장하세요.";
    list.appendChild(div);
    updateMemoActionButtons(memos);
    return;
  }

  memos.forEach(item => {
    const row = document.createElement("div");
    row.className = "log-item";

    const chk = document.createElement("input");
    chk.type = "checkbox";
    chk.className = "log-check";
    chk.checked = memoSelected.has(item.id);
    chk.onchange = () => {
      if (chk.checked) memoSelected.add(item.id);
      else memoSelected.delete(item.id);
      updateMemoActionButtons(memos);
    };

    const body = document.createElement("div");
    body.className = "log-body";

    const time = document.createElement("div");
    time.className = "log-time";
    time.textContent = formatKoreanDateTime(item.at);

    const text = document.createElement("div");
    text.className = "log-text";
    text.textContent = "[입력] " + item.text;

    body.appendChild(time);
    body.appendChild(text);

    const tag = document.createElement("div");
    tag.className = "log-tag";
    const n = findNodeById(state.tree, item.nodeId);
    tag.textContent = (n?.label || (item.nodeId==="root"?"ROOT":"(이름없음)")).replace(/\n/g," / ");

    row.appendChild(chk);
    row.appendChild(body);
    row.appendChild(tag);

    row.addEventListener("click", (e) => {
      if (e.target === chk) return;
      if (window.getSelection()?.toString()) return;
      chk.checked = !chk.checked;
      chk.dispatchEvent(new Event("change"));
    });

    list.appendChild(row);
  });

  updateMemoActionButtons(memos);
}
function updateMemoActionButtons(currentList){
  const memos = currentList || getMemosForCurrentLocation();
  const selCount = memoSelected.size;
  const allSelected = memos.length > 0 && memos.every(x => memoSelected.has(x.id));
  $("memoAllSelect").textContent = allSelected ? "전체 해제" : "전체 선택";

  $("memoAllCopy").disabled = memos.length === 0;
  $("memoSelCopy").disabled = selCount === 0;
  $("memoSelDel").disabled = selCount === 0;
  $("memoSelEdit").disabled = selCount !== 1;
}
async function memoAllSelectToggle(){
  const memos = getMemosForCurrentLocation();
  if (memos.length === 0) return;
  const allSelected = memos.every(x => memoSelected.has(x.id));
  if (allSelected) memoSelected.clear();
  else memoSelected = new Set(memos.map(x => x.id));
  renderMemoWindow();
}
async function memoAllCopy(){
  const memos = getMemosForCurrentLocation();
  if (memos.length === 0) return;
  const text = buildCopyTextFromMemos(memos);
  const ok = await safeCopyText(text);
  alert(ok ? "전체 메모를 복사했습니다." : "복사에 실패했습니다.");
}
async function memoSelCopy(){
  const memos = getMemosForCurrentLocation();
  const pick = memos.filter(x => memoSelected.has(x.id));
  if (pick.length === 0) return;
  const text = buildCopyTextFromMemos(pick);
  const ok = await safeCopyText(text);
  alert(ok ? "선택 메모를 복사했습니다." : "복사에 실패했습니다.");
}
async function memoSelEdit(){
  const memos = getMemosForCurrentLocation();
  const pick = memos.filter(x => memoSelected.has(x.id));
  if (pick.length !== 1) return;
  const target = pick[0];

  const newText = await openMemoEditModal({ initialValue: target.text });
  if (newText === null) return;
  if (!newText) { alert("내용이 비어있습니다."); return; }

  const idx = state.clickLog.findIndex(x => x.id === target.id);
  if (idx >= 0){
    state.clickLog[idx].text = newText;
    await persistState();
  }
  renderMemoWindow();
}
async function memoSelDel(){
  const memos = getMemosForCurrentLocation();
  const pick = memos.filter(x => memoSelected.has(x.id));
  if (pick.length === 0) return;

  const ok = confirm(`선택한 메모 ${pick.length}개를 삭제할까요?`);
  if (!ok) return;

  const delSet = new Set(pick.map(x => x.id));
  state.clickLog = state.clickLog.filter(x => !delSet.has(x.id));
  memoSelected.clear();
  await persistState();
  renderMemoButtonCount();
  renderMemoWindow();
}
async function addMemoFromInput(){
  const ta = $("memoInput");
  const text = normalizeLabel(ta.value ?? "");
  if (!text) return;

  const { nodeId } = getSelectedLabelForMemo();
  state.clickLog.unshift({
    id: genId(),
    at: Date.now(),
    text,
    nodeId,
  });

  ta.value = "";
  memoSelected.clear();
  await persistState();
  renderMemoButtonCount();
  renderMemoWindow();
}

/* ===== Memo window drag + resize persist ===== */
let memoDragging = false;
let memoDragStartX = 0, memoDragStartY = 0;
let memoStartLeft = 0, memoStartTop = 0;
let memoResizeObs = null;

function bindMemoWindowDragResize(){
  const win = $("memoWindow");
  const header = $("memoHeader");
  if (!win || !header) return;

  header.addEventListener("pointerdown", (e) => {
    const tag = (e.target && e.target.tagName) ? e.target.tagName.toLowerCase() : "";
    if (tag === "button" || tag === "input" || tag === "textarea") return;

    memoDragging = true;
    header.setPointerCapture?.(e.pointerId);

    const rect = win.getBoundingClientRect();
    memoDragStartX = e.clientX;
    memoDragStartY = e.clientY;
    memoStartLeft = rect.left;
    memoStartTop = rect.top;
    e.preventDefault();
  });

  window.addEventListener("pointermove", (e) => {
    if (!memoDragging) return;
    const dx = e.clientX - memoDragStartX;
    const dy = e.clientY - memoDragStartY;

    const vw = window.innerWidth;
    const vh = window.innerHeight;

    const rect = win.getBoundingClientRect();
    const w = rect.width;
    const h = rect.height;

    let nx = memoStartLeft + dx;
    let ny = memoStartTop + dy;

    nx = Math.max(0, Math.min(vw - 40, nx));
    ny = Math.max(0, Math.min(vh - 40, ny));

    win.style.left = nx + "px";
    win.style.top = ny + "px";
  });

  window.addEventListener("pointerup", async () => {
    if (!memoDragging) return;
    memoDragging = false;

    const rect = win.getBoundingClientRect();
    state.ui.memoX = Math.round(rect.left);
    state.ui.memoY = Math.round(rect.top);
    await persistState();
  });

  if (memoResizeObs) memoResizeObs.disconnect();
  memoResizeObs = new ResizeObserver(async () => {
    if (!state.ui.memoOpen) return;
    const rect = win.getBoundingClientRect();
    state.ui.memoW = Math.round(rect.width);
    state.ui.memoH = Math.round(rect.height);
    await persistState();
  });
  memoResizeObs.observe(win);

  window.addEventListener("resize", () => applyMemoWindowFromState());
}

/* =========================================================
   ✅ (추가) 메모 수정 모달 드래그 + 초기 위치
   ========================================================= */
let memoEditDragging = false;
let memoEditStartX = 0, memoEditStartY = 0;
let memoEditStartLeft = 0, memoEditStartTop = 0;

function positionMemoEditModalInitial(){
  const backdrop = $("memoEditModal");
  const modal = backdrop?.querySelector(".modal");
  if (!backdrop || !modal) return;

  modal.style.position = "fixed";

  const pad = 12;
  const vw = window.innerWidth;
  const vh = window.innerHeight;

  const memoWin = $("memoWindow");
  let x = Math.floor(vw/2 - modal.getBoundingClientRect().width/2);
  let y = Math.floor(vh/2 - modal.getBoundingClientRect().height/2);

  if (state.ui.memoOpen && memoWin && memoWin.classList.contains("show")){
    const r = memoWin.getBoundingClientRect();
    x = Math.round(r.left + 40);
    y = Math.round(r.top + 24);
  }

  const rect = modal.getBoundingClientRect();
  const mw = rect.width || 520;
  const mh = rect.height || 220;

  x = Math.max(pad, Math.min(vw - mw - pad, x));
  y = Math.max(pad, Math.min(vh - mh - pad, y));

  modal.style.left = x + "px";
  modal.style.top  = y + "px";
}

function bindMemoEditModalDrag(){
  const backdrop = $("memoEditModal");
  const modal = backdrop?.querySelector(".modal");
  const handle = modal?.querySelector("h3");
  if (!backdrop || !modal || !handle) return;

  handle.addEventListener("pointerdown", (e) => {
    memoEditDragging = true;
    handle.setPointerCapture?.(e.pointerId);

    modal.style.position = "fixed";
    const r = modal.getBoundingClientRect();
    memoEditStartX = e.clientX;
    memoEditStartY = e.clientY;
    memoEditStartLeft = r.left;
    memoEditStartTop  = r.top;

    e.preventDefault();
  });

  window.addEventListener("pointermove", (e) => {
    if (!memoEditDragging) return;
    const dx = e.clientX - memoEditStartX;
    const dy = e.clientY - memoEditStartY;

    const pad = 12;
    const vw = window.innerWidth;
    const vh = window.innerHeight;

    const r = modal.getBoundingClientRect();
    const mw = r.width;
    const mh = r.height;

    let nx = memoEditStartLeft + dx;
    let ny = memoEditStartTop + dy;

    nx = Math.max(pad, Math.min(vw - mw - pad, nx));
    ny = Math.max(pad, Math.min(vh - mh - pad, ny));

    modal.style.left = nx + "px";
    modal.style.top  = ny + "px";
  });

  window.addEventListener("pointerup", () => {
    memoEditDragging = false;
  });
}

/* ===== Render Buttons ===== */
function renderButtons(){
  ensureMainButtonPx();
  const container = $("buttonContainer");
  container.innerHTML = "";

  const parent = getCurrentParentNode();
  const children = parent.children || [];

  if (children.length === 0) {
    const div = document.createElement("div");
    div.className="empty-text";
    div.textContent="이 위치에는 버튼이 없습니다.\n아래의 '+ 새버튼'으로 추가하세요.";
    container.appendChild(div);
    return;
  }

  const mainPx = state.ui.mainButtonPx;

  children.forEach((child) => {
    const row = document.createElement("div");
    row.className="btn-row";

    const main = document.createElement("button");
    main.type = "button";
    main.className = "btn-main" + (selectedNodeId === child.id ? " active" : "");
    main.textContent = child.label;
    main.style.width = mainPx + "px";

    main.onclick = async () => {
      selectedNodeId = child.id;
      if (child.children && child.children.length > 0) currentParentId = child.id;

      if (state.ui.moveMode){
        moveState.sourceId = (selectedNodeId !== "root") ? selectedNodeId : null;
        moveState.targetId = null;
        $("moveSearchInput").value = "";
        hideMoveDropdown();
        updateMovePills();
      }

      if (state.ui.memoOpen) {
        memoSelected.clear();
        renderMemoWindow();
      }

      await persistState();
      render();
    };

    const controls = document.createElement("div");
    controls.className="btn-controls";

    const viewBtn = document.createElement("button");
    viewBtn.type = "button";
    viewBtn.textContent = "내용";
    viewBtn.title = "이 버튼의 내용을 우측에 표시";
    viewBtn.onclick = async () => {
      selectedNodeId = child.id;
      noteEditMode = false;

      if (state.ui.moveMode){
        moveState.sourceId = (selectedNodeId !== "root") ? selectedNodeId : null;
        moveState.targetId = null;
        $("moveSearchInput").value = "";
        hideMoveDropdown();
        updateMovePills();
      }

      if (state.ui.memoOpen) {
        memoSelected.clear();
        renderMemoWindow();
      }

      await persistState();
      render();
      $("rightScrollWrap").scrollTop = 0;
    };

    const renameBtn = document.createElement("button");
    renameBtn.type="button";
    renameBtn.textContent="이름";
    renameBtn.onclick = async () => {
      const n = await openNameModal({ title: "새 이름", initialValue: child.label });
      if (n === null || !n) return;
      child.label = n;
      await persistState(); render();
      if (state.ui.memoOpen) renderMemoWindow();
    };

    const delBtn = document.createElement("button");
    delBtn.type="button";
    delBtn.textContent="삭제";
    delBtn.onclick = async () => {
      const oneLine = (child.label || "").replace(/\n/g, " / ");
      if (!confirm("'" + oneLine + "' 버튼을 삭제할까요?\n(하위버튼/내용도 함께 삭제됩니다)")) return;

      const parent = getCurrentParentNode();
      parent.children = parent.children.filter(x => x.id !== child.id);

      state.clickLog = (state.clickLog||[]).filter(x => x.nodeId !== child.id);

      if (selectedNodeId === child.id) selectedNodeId = parent.id;

      memoSelected.clear();
      await persistState();
      render();
      if (state.ui.memoOpen) renderMemoWindow();
    };

    const upBtn = document.createElement("button");
    upBtn.type="button";
    upBtn.textContent="▲";
    upBtn.title="위로";
    upBtn.onclick = async () => {
      const parent = getCurrentParentNode();
      const idx = parent.children.findIndex(x => x.id === child.id);
      const targetIdx = idx - 1;
      if (targetIdx < 0) return;

      const tmp = parent.children[idx];
      parent.children[idx] = parent.children[targetIdx];
      parent.children[targetIdx] = tmp;

      await persistState();
      renderButtons();
    };

    const downBtn = document.createElement("button");
    downBtn.type="button";
    downBtn.textContent="▼";
    downBtn.title="아래로";
    downBtn.onclick = async () => {
      const parent = getCurrentParentNode();
      const idx = parent.children.findIndex(x => x.id === child.id);
      const targetIdx = idx + 1;
      if (targetIdx >= parent.children.length) return;

      const tmp = parent.children[idx];
      parent.children[idx] = parent.children[targetIdx];
      parent.children[targetIdx] = tmp;

      await persistState();
      renderButtons();
    };

    controls.appendChild(viewBtn);
    controls.appendChild(renameBtn);
    controls.appendChild(delBtn);
    controls.appendChild(upBtn);
    controls.appendChild(downBtn);

    row.appendChild(main);
    row.appendChild(controls);
    container.appendChild(row);
  });
}

/* ===== Render ===== */
function render(){
  syncModeButtons();
  renderBreadcrumb();
  renderButtons();
  renderNotePanel();
  applyPropSplitFromState(); // ✅ 내부 split 반영
  if (state.ui.memoOpen) renderMemoWindow();
}

/* ===== Events ===== */
function bindEvents(){
  bindNameModalEvents();
  bindMemoEditModalEvents();
  bindBackupNameModalEvents();
  bindEditorTools();
  bindStatsEvents();
  bindHCtrl("left");
  bindHCtrl("right");

  onClick("btnUp", async () => {
    const parent = findParentNode(state.tree, currentParentId);
    if (!parent) return;
    currentParentId = parent.id;
    selectedNodeId = parent.id;

    if (state.ui.moveMode){
      moveState.sourceId = null; moveState.targetId = null;
      $("moveSearchInput").value = "";
      hideMoveDropdown();
      updateMovePills();
    }

    if (state.ui.memoOpen) {
      memoSelected.clear();
      renderMemoWindow();
    }

    await persistState();
    render();
  });

  onClick("btnAll", async () => {
    currentParentId = "root"; selectedNodeId = "root";
    if (state.ui.moveMode){
      moveState.sourceId = null; moveState.targetId = null;
      $("moveSearchInput").value = "";
      hideMoveDropdown();
      updateMovePills();
    }

    if (state.ui.memoOpen) {
      memoSelected.clear();
      renderMemoWindow();
    }

    await persistState();
    render();
  });

  onClick("btnAddHere", async () => {
    const parent = getCurrentParentNode();
    const name = await openNameModal({ title: "새 버튼 이름", initialValue: "" });
    if (name === null || !name) return;
    parent.children.push({ id: genId(), label: name, note:"", noteHtml:null, children:[] });
    await persistState(); render();
  });

  onClick("btnAddChildQuick", async () => {
    if (!selectedNodeId || selectedNodeId === "root") {
      alert("하위버튼을 추가할 '버튼'을 먼저 선택해주세요.\n(현재 선택: 전체)");
      return;
    }
    const node = findNodeById(state.tree, selectedNodeId);
    if (!node) { alert("선택된 버튼을 찾지 못했습니다."); return; }

    const name = await openNameModal({ title: "하위 버튼 이름", initialValue: "" });
    if (name === null || !name) return;

    if (!Array.isArray(node.children)) node.children = [];
    const newId = genId();
    node.children.push({ id: newId, label: name, note:"", noteHtml:null, children:[] });

    currentParentId = node.id;
    selectedNodeId = newId;

    await persistState();
    render();
  });

  onClick("btnEditMode", async () => { state.ui.editMode = !state.ui.editMode; syncModeButtons(); await persistState(); });
  onClick("btnBackupMode", async () => { state.ui.backupMode = !state.ui.backupMode; syncModeButtons(); await persistState(); });

  onClick("btnBackupDownload", async () => { await doBackupDownload(); });
  onClick("btnBackupUpload", () => { $("backupFileInput").click(); });
  $("backupFileInput").addEventListener("change", async (e) => {
    const file = e.target.files && e.target.files[0];
    e.target.value = "";
    await doBackupRestoreFromFile(file);
  });

  onClick("btnMoveMode", async () => { setMoveMode(!state.ui.moveMode); await persistState(); });
  onClick("btnMoveCancel", async () => { setMoveMode(false); await persistState(); });
  onInput("moveSearchInput", (e) => runMoveTargetSearch(e.target.value));
  onClick("btnMoveConfirm", async () => { await executeMove(); await persistState(); });

  onClick("btnSearchMode", async () => { setSearchMode(!state.ui.searchMode); await persistState(); });
  onClick("btnSearchClose", async () => { setSearchMode(false); await persistState(); });
  onClick("btnSearchClear", () => {
    $("searchInput").value = "";
    $("searchCountPill").textContent = "검색: 0";
    hideSearchDropdown();
    $("searchInput").focus();
  });
  onInput("searchInput", (e) => { runSearch(e.target.value); });
  $("searchInput").addEventListener("keydown", (e) => {
    if (e.key === "Enter") {
      e.preventDefault();
      runSearch(e.target.value);
    } else if (e.key === "Escape") {
      e.preventDefault();
      setSearchMode(false);
      persistState();
    }
  });
  document.addEventListener("click", (e) => {
    if (!state.ui.searchMode) return;
    const box = $("searchBox");
    if (!box) return;
    if (!box.contains(e.target)) hideSearchDropdown();
  });

  $("btnWidthRange").addEventListener("input", async (e) => {
    const v = Number(e.target.value || 15);
    state.ui.buttonWidthPct = v;
    $("btnWidthVal").textContent = String(v);
    state.ui.mainButtonPx = computeMainButtonPxFromCurrentVisible();
    await persistState();
    renderButtons();
  });

  onClick("btnNoteEdit", () => { noteEditMode = true; renderNotePanel(); setTimeout(()=>$("noteEditor").focus(),0); });
  onClick("btnNoteCancel", () => { noteEditMode = false; renderNotePanel(); });
  onClick("btnNoteSave", async () => {
    const node = findNodeById(state.tree, selectedNodeId) || state.tree;
    node.noteHtml = $("noteEditor").innerHTML ?? "";
    node.note = $("noteEditor").innerText ?? "";
    await persistState();
    noteEditMode = false;
    renderNotePanel();
  });

  onClick("btnMemoMode", () => { toggleMemoWindow(); });
  onClick("memoClose", () => closeMemoWindow());

  $("memoInput").addEventListener("keydown", async (e) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      await addMemoFromInput();
    }
  });

  onClick("memoAllSelect", async () => { await memoAllSelectToggle(); });
  onClick("memoAllCopy", async () => { await memoAllCopy(); });
  onClick("memoSelCopy", async () => { await memoSelCopy(); });
  onClick("memoSelEdit", async () => { await memoSelEdit(); });
  onClick("memoSelDel", async () => { await memoSelDel(); });
}

(async function init(){
  try {
    await loadState();
    ensureNodeFields(state.tree);
    migrateRootLabel(state.tree);
    ensureMemoFields();

    ensureMainButtonPx();
    applySplitFromState();
    bindSplitDrag();

    // ✅ 내부 split 바인딩
    applyPropSplitFromState();
    bindPropSplitDrag();

    bindMemoWindowDragResize();
    bindEvents();
    bindMemoEditModalDrag();

    applyMemoWindowFromState();
    renderMemoButtonCount();

    render();

    if (state.ui.moveMode) setMoveMode(true);
    if (state.ui.searchMode) setSearchMode(true);
    if (state.ui.memoOpen) {
      $("memoWindow").classList.add("show");
      renderMemoWindow();
    }
  } catch (err) {
    console.error(err);
    alert("초기화 중 오류가 발생했습니다. 콘솔(F12)을 확인해주세요.");
  }
})();
</script>
</body>
</html>
